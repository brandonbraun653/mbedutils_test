/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "thread_intf_expect.hpp"

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& initialize()
{
    return initialize(1);
}
MockExpectedCall& initialize(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::initialize");
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& create_task(CppUMockGen::Parameter<const mb::thread::TaskConfig &> cfg, mb::thread::TaskHandle __return__)
{
    return create_task(1, cfg, __return__);
}
MockExpectedCall& create_task(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::thread::TaskConfig &> cfg, mb::thread::TaskHandle __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::create_task");
    if(cfg.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("mb::thread::TaskConfig", "cfg", &cfg.getValue()); }
    __expectedCall__.andReturnValue(static_cast<void*>(__return__));
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& destroy_task(CppUMockGen::Parameter<mb::thread::TaskHandle> task)
{
    return destroy_task(1, task);
}
MockExpectedCall& destroy_task(unsigned int __numCalls__, CppUMockGen::Parameter<mb::thread::TaskHandle> task)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::destroy_task");
    if(task.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withPointerParameter("task", task.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& set_affinity(CppUMockGen::Parameter<mb::thread::TaskHandle> task, CppUMockGen::Parameter<size_t> coreId)
{
    return set_affinity(1, task, coreId);
}
MockExpectedCall& set_affinity(unsigned int __numCalls__, CppUMockGen::Parameter<mb::thread::TaskHandle> task, CppUMockGen::Parameter<size_t> coreId)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::set_affinity");
    if(task.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withPointerParameter("task", task.getValue()); }
    if(coreId.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("coreId", coreId.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& start_scheduler()
{
    return start_scheduler(1);
}
MockExpectedCall& start_scheduler(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::start_scheduler");
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& on_stack_overflow()
{
    return on_stack_overflow(1);
}
MockExpectedCall& on_stack_overflow(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::on_stack_overflow");
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& on_malloc_failed()
{
    return on_malloc_failed(1);
}
MockExpectedCall& on_malloc_failed(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::on_malloc_failed");
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& on_idle()
{
    return on_idle(1);
}
MockExpectedCall& on_idle(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::on_idle");
    return __expectedCall__;
}
} } } }

namespace expect { namespace mb$ { namespace thread$ { namespace intf$ {
MockExpectedCall& on_tick()
{
    return on_tick(1);
}
MockExpectedCall& on_tick(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::thread::intf::on_tick");
    return __expectedCall__;
}
} } } }

