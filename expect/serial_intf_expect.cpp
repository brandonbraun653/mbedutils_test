/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "serial_intf_expect.hpp"

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& lock(CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<const size_t> timeout, bool __return__)
{
    return lock(1, channel, timeout, __return__);
}
MockExpectedCall& lock(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<const size_t> timeout, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::lock");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(timeout.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("timeout", timeout.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& unlock(CppUMockGen::Parameter<const size_t> channel)
{
    return unlock(1, channel);
}
MockExpectedCall& unlock(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::unlock");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& flush(CppUMockGen::Parameter<const size_t> channel)
{
    return flush(1, channel);
}
MockExpectedCall& flush(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::flush");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& disable_interrupts(CppUMockGen::Parameter<const size_t> channel)
{
    return disable_interrupts(1, channel);
}
MockExpectedCall& disable_interrupts(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::disable_interrupts");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& enable_interrupts(CppUMockGen::Parameter<const size_t> channel)
{
    return enable_interrupts(1, channel);
}
MockExpectedCall& enable_interrupts(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::enable_interrupts");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& write_async(CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<const void *> data, CppUMockGen::Parameter<const size_t> length, int __return__)
{
    return write_async(1, channel, data, length, __return__);
}
MockExpectedCall& write_async(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<const void *> data, CppUMockGen::Parameter<const size_t> length, int __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::write_async");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(data.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("data", data.getValue()); }
    if(length.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("length", length.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& on_tx_complete(CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<mb::hw::serial::intf::TXCompleteCallback&> callback)
{
    return on_tx_complete(1, channel, callback);
}
MockExpectedCall& on_tx_complete(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<mb::hw::serial::intf::TXCompleteCallback&> callback)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::on_tx_complete");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(callback.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("mb::hw::serial::intf::TXCompleteCallback", "callback", &callback.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& write_abort(CppUMockGen::Parameter<const size_t> channel)
{
    return write_abort(1, channel);
}
MockExpectedCall& write_abort(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::write_abort");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& read_async(CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<void *> data, CppUMockGen::Parameter<const size_t> length, CppUMockGen::Parameter<const size_t> timeout, int __return__)
{
    return read_async(1, channel, data, length, timeout, __return__);
}
MockExpectedCall& read_async(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<void *> data, CppUMockGen::Parameter<const size_t> length, CppUMockGen::Parameter<const size_t> timeout, int __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::read_async");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(data.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withPointerParameter("data", data.getValue()); }
    if(length.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("length", length.getValue()); }
    if(timeout.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("timeout", timeout.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& on_rx_complete(CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<mb::hw::serial::intf::RXCompleteCallback&> callback)
{
    return on_rx_complete(1, channel, callback);
}
MockExpectedCall& on_rx_complete(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel, CppUMockGen::Parameter<mb::hw::serial::intf::RXCompleteCallback&> callback)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::on_rx_complete");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(callback.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("mb::hw::serial::intf::RXCompleteCallback", "callback", &callback.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace serial$ { namespace intf$ {
MockExpectedCall& read_abort(CppUMockGen::Parameter<const size_t> channel)
{
    return read_abort(1, channel);
}
MockExpectedCall& read_abort(unsigned int __numCalls__, CppUMockGen::Parameter<const size_t> channel)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::serial::intf::read_abort");
    if(channel.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("channel", channel.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

