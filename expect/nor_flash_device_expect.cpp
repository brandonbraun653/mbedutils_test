/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "nor_flash_device_expect.hpp"

namespace expect { namespace mb$ { namespace memory$ { namespace nor$ { namespace device$ {
MockExpectedCall& adesto_at25sfxxx_pend_event(CppUMockGen::Parameter<const mb::memory::nor::DeviceConfig &> cfg, CppUMockGen::Parameter<const mb::memory::nor::Event> event, CppUMockGen::Parameter<const size_t> timeout, mb::memory::Status __return__)
{
    return adesto_at25sfxxx_pend_event(1, cfg, event, timeout, __return__);
}
MockExpectedCall& adesto_at25sfxxx_pend_event(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::memory::nor::DeviceConfig &> cfg, CppUMockGen::Parameter<const mb::memory::nor::Event> event, CppUMockGen::Parameter<const size_t> timeout, mb::memory::Status __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::memory::nor::device::adesto_at25sfxxx_pend_event");
    if(cfg.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("mb::memory::nor::DeviceConfig", "cfg", &cfg.getValue()); }
    if(event.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withIntParameter("event", static_cast<int>(event.getValue())); }
    if(timeout.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("timeout", timeout.getValue()); }
    __expectedCall__.andReturnValue(static_cast<int>(__return__));
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

