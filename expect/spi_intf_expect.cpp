/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++20
 */

#include "spi_intf_expect.hpp"

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& init(CppUMockGen::Parameter<const mb::hw::spi::SpiConfig &> config)
{
    return init(1, config);
}
MockExpectedCall& init(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::SpiConfig &> config)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::init");
    if(config.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withParameterOfType("mb::hw::spi::SpiConfig", "config", &config.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& deinit(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    return deinit(1, port);
}
MockExpectedCall& deinit(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::deinit");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& write(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<const void *const> data, CppUMockGen::Parameter<const size_t> length)
{
    return write(1, port, data, length);
}
MockExpectedCall& write(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<const void *const> data, CppUMockGen::Parameter<const size_t> length)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::write");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(data.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("data", data.getValue()); }
    if(length.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("length", length.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& read(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<void *const> data, CppUMockGen::Parameter<const size_t> length)
{
    return read(1, port, data, length);
}
MockExpectedCall& read(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<void *const> data, CppUMockGen::Parameter<const size_t> length)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::read");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(data.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withPointerParameter("data", data.getValue()); }
    if(length.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("length", length.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& transfer(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<const void *const> tx, CppUMockGen::Parameter<void *const> rx, CppUMockGen::Parameter<const size_t> length)
{
    return transfer(1, port, tx, rx, length);
}
MockExpectedCall& transfer(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port, CppUMockGen::Parameter<const void *const> tx, CppUMockGen::Parameter<void *const> rx, CppUMockGen::Parameter<const size_t> length)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::transfer");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(tx.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("tx", tx.getValue()); }
    if(rx.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withOutputParameterReturning("rx", rx.getValue(), sizeof( rx.getValue() ) ); }
    if(length.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedLongIntParameter("length", length.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& lock(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    return lock(1, port);
}
MockExpectedCall& lock(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::lock");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

namespace expect { namespace mb$ { namespace hw$ { namespace spi$ { namespace intf$ {
MockExpectedCall& unlock(CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    return unlock(1, port);
}
MockExpectedCall& unlock(unsigned int __numCalls__, CppUMockGen::Parameter<const mb::hw::spi::Port_t> port)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "mb::hw::spi::intf::unlock");
    if(port.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withUnsignedIntParameter("port", port.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} } } } }

